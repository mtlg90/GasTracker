<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>GAS T. â€” Gas Tracker</title>

  <!-- Icons (carica i file in repository root) -->
  <link rel="apple-touch-icon" sizes="180x180" href="icon-180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="icon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="icon-16.png">
  <link rel="mask-icon" href="icon.svg" color="#7c3aed">
  <meta name="theme-color" content="#071023">

  <style>
    :root{
      --bg1:#071023; --bg2:#071428; --text:#e6eef8; --muted:#9ca3af;
      --accent1:#7c3aed; --accent2:#06b6d4; --glass:rgba(255,255,255,0.03);
      --radius:14px; --gap:14px; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--text);-webkit-font-smoothing:antialiased}
    .container{max-width:1100px;margin:20px auto;padding:18px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .brand{display:flex;align-items:center;gap:12px}
    .logo-box{display:flex;align-items:center;gap:12px}
    .logo-img{height:46px; width:auto; display:block}
    h1{font-size:20px;margin:0}
    .subtitle{color:var(--muted);font-size:13px}
    .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:var(--gap);margin-top:18px}
    .card{background:linear-gradient(180deg,var(--glass),rgba(255,255,255,0.015));backdrop-filter: blur(6px);border-radius:var(--radius);padding:14px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
    .col-span-4{grid-column:span 4}
    .col-span-8{grid-column:span 8}
    label{font-size:13px;color:var(--muted);display:block;margin-top:8px}
    input,textarea,select{width:100%;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit;box-sizing:border-box}
    textarea{min-height:64px;resize:vertical}
    .row{display:flex;gap:10px}
    button{background:linear-gradient(90deg,var(--accent1),var(--accent2));border:none;padding:10px 14px;border-radius:12px;color:#fff;font-weight:600;cursor:pointer}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    .stats{display:flex;gap:12px;flex-wrap:wrap}
    .stat{flex:1;padding:14px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));text-align:center;min-width:140px;cursor:pointer}
    .stat .label{font-size:12px;color:var(--muted)}
    .stat .value{font-size:16px;font-weight:700;margin-top:6px}
    .stats-grid{display:grid;grid-template-columns: repeat(3, 1fr);grid-auto-rows: minmax(64px, auto);gap: 10px;margin-top: 12px;}
    @media(max-width:960px){ .stats-grid{grid-template-columns:repeat(2,1fr)} }
    @media(max-width:760px){ .grid{grid-template-columns:1fr} .col-span-4,.col-span-8{grid-column:1} .stats-grid{grid-template-columns:1fr} }
    table{width:100%;border-collapse:collapse;margin-top:10px;font-size:13px}
    th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,0.03);text-align:left}
    .chart-wrap{height:260px;padding:10px}
    .small{font-size:12px;color:var(--muted)}
    /* overlay (non trasparente) */
    .overlay { position: fixed; inset:0; display:none; align-items:flex-start; justify-content:center; padding:24px; z-index:200; overflow:auto; }
    .overlay.active{ display:flex; }
    .panel { background: linear-gradient(180deg, #0b1220, #071023); border-radius:12px; padding:16px; width:100%; max-width:980px; box-shadow:0 30px 80px rgba(0,0,0,0.8); border: 1px solid rgba(255,255,255,0.03); color:var(--text); }
    .tabs{display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap}
    .tabs button{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px 12px;border-radius:8px;cursor:pointer}
    .tabs button.active{background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#fff;border:none}
    .group { margin-bottom:12px; border-radius:8px; padding:10px; background: rgba(255,255,255,0.02) }
    .group h5{margin:0 0 6px 0}
    .small-action{padding:6px 10px;border-radius:8px;font-size:13px}
    .muted-btn{background:transparent;border:1px dashed rgba(255,255,255,0.04);color:var(--muted)}
    /* forecast small card styling */
    .forecast-card { margin-top:12px; padding:12px; border-radius:10px; background:linear-gradient(180deg, rgba(11,18,32,0.6), rgba(7,16,35,0.6)); border:1px solid rgba(255,255,255,0.03); }
    .forecast-result { background: linear-gradient(90deg, rgba(10,132,255,0.08), rgba(124,58,237,0.06)); padding:12px; border-radius:8px; margin-top:10px; border-left:3px solid var(--accent1); }
    /* touch improvements */
    button, input, textarea { -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
  </style>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
</head>
<body>
  <div class="container">
    <header>
      <div class="brand logo-box">
        <img id="logoImg" class="logo-img" src="logo-text.svg" alt="GAS T. â€” Gas Tracker" />
        <div>
          <h1 style="margin:0">GAS T.</h1>
          <div class="subtitle">Consumi â€¢ Previsioni â€¢ Storico</div>
        </div>
      </div>

      <div style="display:flex;gap:8px;align-items:center">
        <button id="exportBtn" class="ghost small-action" title="Esporta CSV">Esporta CSV</button>
        <button id="importBtn" class="ghost small-action" title="Importa CSV">Importa CSV</button>
        <button id="saveBtn" class="small-action" title="Salva lettura">Salva</button>
      </div>
    </header>

    <div class="grid" role="main">
      <!-- Left: input -->
      <div class="card col-span-4" aria-labelledby="paramsTitle">
        <h3 id="paramsTitle">Parametri & nuova lettura</h3>

        <label>Prezzo materia prima (â‚¬/Smc)
          <input id="price_mp" type="number" step="0.0001" value="0.80" />
        </label>
        <label>Oneri fissi mensili (â‚¬)
          <input id="fixed_charge" type="number" step="0.01" value="10.00" />
        </label>

        <h4 style="margin-top:12px">Aggiungi / Modifica lettura</h4>
        <label>Data
          <input id="date" type="date" />
        </label>

        <div class="row" style="margin-top:6px">
          <div style="flex:1">
            <label>Lettura (Smc)
              <input id="reading" type="number" step="0.001" placeholder="es. 1234.567" />
            </label>
          </div>
          <div style="width:120px">
            <label>Ora
              <input id="time" type="time" />
            </label>
          </div>
        </div>

        <label>Temperatura minima (Â°C)
          <input id="temp" type="number" step="0.1" placeholder="es. 3.5" />
        </label>
        <label>Note (opzionale)
          <textarea id="notes" placeholder="es. weekend fuori casa"></textarea>
        </label>

        <div style="display:flex;gap:10px;margin-top:10px">
          <button id="addBtn">Aggiungi</button>
          <button id="cancelEditBtn" class="ghost" style="display:none">Annulla</button>
          <button id="clearBtn" class="ghost">Cancella tutto</button>
        </div>

        <div id="message" class="small" style="margin-top:8px"></div>
      </div>

      <!-- Right: stats + chart + readings + monthly -->
      <div class="card col-span-8" aria-labelledby="statsTitle">
        <div style="text-align:center">
          <h3 id="statsTitle" style="margin:0">Statistiche & grafico</h3>
          <div class="small" style="margin-top:6px">Ultima lettura del giorno usata per calcoli â€” clicca su una card per vedere lo storico dettagliato</div>
        </div>

        <div class="stats-grid" aria-hidden="false">
          <div id="statTotal" class="stat" title="Numero di giorni con letture"><div class="label">Giorni registrati</div><div class="value" id="total">0</div></div>
          <div id="statAvgDaily" class="stat" title="Media giornaliera calcolata da differenze giornaliere"><div class="label">Media/giorno (Smc)</div><div class="value" id="avgDaily">-</div></div>
          <div id="statEstDaily" class="stat" title="Stima giornaliera basata sulla media"><div class="label">Stima giornaliera (Smc)</div><div class="value" id="estDailySmc">-</div></div>

          <div id="statEstWeekly" class="stat"><div class="label">Stima settimanale (Smc)</div><div class="value" id="estWeeklySmc">-</div></div>
          <div id="statEstMonthly" class="stat"><div class="label">Stima 30gg (Smc)</div><div class="value" id="estMonthlySmc">-</div></div>
          <div id="statEstMonthlyCost" class="stat"><div class="label">Costo stimato mensile (â‚¬)</div><div class="value" id="estMonthlyCost">-</div></div>
        </div>

        <div class="chart-wrap card" style="margin-top:12px">
          <canvas id="chart"></canvas>
        </div>

        <!-- Forecast small panel integrated into right column -->
        <div class="forecast-card">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <h3 style="margin:0">ðŸ“ˆ Previsione Bolletta (mese corrente)</h3>
              <div class="small muted">Materia prima PSV â†’ conversione â†’ previsione</div>
            </div>
            <div style="display:flex;gap:8px;align-items:center">
              <button id="btnFetchPsv" class="ghost small-action" title="Scarica PSV">Fetch PSV</button>
              <button id="btnSaveForecastParams" class="ghost small-action" title="Salva parametri">Salva parametri</button>
            </div>
          </div>

          <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px">
            <div>
              <label>Prezzo PSV (â‚¬/MWh) â€” media giorni passati</label>
              <input id="forecast_psv_mwh" type="text" placeholder="es. 45.3">
            </div>
            <div>
              <label>Prezzo (â‚¬/Smc) â€” inserisci se preferisci</label>
              <input id="forecast_psv_smc" type="text" placeholder="es. 0.48">
            </div>
          </div>

          <div style="display:flex;gap:10px;margin-top:10px;align-items:center">
            <div style="flex:1">
              <label>Lettura attuale (Smc)</label>
              <input id="forecast_lettura_input" type="number" step="0.001" placeholder="usa il pulsante per usare l'ultima lettura" />
            </div>
            <div style="width:140px">
              <label>Giorno di riferimento</label>
              <input id="forecast_date_input" type="date" />
            </div>
          </div>

          <div style="display:flex;gap:10px;margin-top:10px">
            <button id="btnCalcForecast">Calcola previsione</button>
            <button id="btnResetForecast" class="muted-btn">Reset</button>
          </div>

          <div id="forecast_output" style="margin-top:12px; display:none" class="forecast-result"></div>

          <div style="margin-top:10px" class="small muted">
            <div>Ultimi PSV salvati: <span id="psv_last_count">0</span></div>
            <div>Ultimo fetch: <span id="psv_last_time">-</span></div>
          </div>
        </div>

        <h4 style="margin-top:12px">Registro letture</h4>
        <table role="table" aria-label="Registro letture">
          <thead><tr><th>Data</th><th>Ora</th><th>Smc</th><th>Temp</th><th>Note</th><th>Azioni</th></tr></thead>
          <tbody id="readingsBody"></tbody>
        </table>

        <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
          <div class="small">Consumo oggi (intra-day): <strong id="todayConsumption">-</strong></div>
          <div class="small">Stima giornaliera (â‚¬): <strong id="estDailyCost">-</strong></div>
          <div class="small">Stima settimanale (â‚¬): <strong id="estWeeklyCost">-</strong></div>
        </div>

        <h4 style="margin-top:14px">Consumo mensile (per mese)</h4>
        <table role="table" aria-label="Consumo mensile">
          <thead><tr><th>Mese</th><th>Consumo (Smc)</th><th>Media giornaliera (Smc/giorno)</th><th>Costo stimato (â‚¬)</th></tr></thead>
          <tbody id="monthlyBody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Overlay: cronologia (non trasparente) -->
  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="panel" role="dialog" aria-modal="true" aria-labelledby="historyTitle">
      <div style="display:flex;align-items:center;justify-content:space-between">
        <h3 id="historyTitle">Cronologia consumi</h3>
        <div>
          <button id="exportHistoryBtn" class="ghost small-action">Esporta vista CSV</button>
          <button id="closeOverlay" class="small-action" style="margin-left:8px">Chiudi</button>
        </div>
      </div>

      <div class="tabs" id="historyTabs">
        <button data-tab="daily" class="active">Giornaliero</button>
        <button data-tab="monthly">Mensile</button>
        <button data-tab="yearly">Annuale</button>
      </div>

      <div id="historyContent" style="max-height:60vh; overflow:auto; padding-right:6px">
        <!-- contenuto dinamico -->
      </div>
    </div>
  </div>

  <input id="fileImport" type="file" accept=".csv,text/csv" style="display:none" />

<script>
/* ================== Firebase config (Realtime DB) ================== */
const firebaseConfig = {
  apiKey: "AIzaSyCdY2xuLVTBmwUbs-sud5g6W-7eedoI1Qk",
  authDomain: "gastracker-a4bc5.firebaseapp.com",
  databaseURL: "https://gastracker-a4bc5-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "gastracker-a4bc5",
  storageBucket: "gastracker-a4bc5.firebasestorage.app",
  messagingSenderId: "523976617358",
  appId: "1:523976617358:web:1494df462f40813ec548df"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ================== Utilities ================== */
let editingKey = null;
function showMessage(msg, type){
  const el = document.getElementById('message');
  if(!el) return;
  el.textContent = msg || '';
  el.style.color = type === 'error' ? '#fca5a5' : (type === 'ok' ? '#86efac' : 'var(--muted)');
  if(msg) setTimeout(()=>{ if(el.textContent===msg) el.textContent=''; }, 3000);
}
function isoWithTime(dateStr, timeStr){
  if(!timeStr) timeStr = '00:00:00';
  if(timeStr.length===5) timeStr += ':00';
  return `${dateStr}T${timeStr}`;
}

/* ================== Chart init ================== */
let chart;
function initChart(){
  const ctx = document.getElementById('chart').getContext('2d');
  chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [
        { label: 'Smc (ultima lettura/giorno)', yAxisID: 'y1', data: [], fill: false, tension: 0.3, borderColor: '#7c3aed', pointRadius: 3 },
        { label: 'PSV â‚¬/Smc', yAxisID: 'y2', data: [], fill: false, tension: 0.3, borderColor: '#06b6d4', pointRadius: 2, borderDash: [4,3] }
      ]
    },
    options: {
      responsive: true,
      interaction: { mode: 'index', intersect: false },
      plugins: { legend: { display: true }},
      scales: {
        x: { display: true },
        y1: { type: 'linear', position: 'left', title: { display:true, text: 'Smc' } },
        y2: { type: 'linear', position: 'right', grid: { drawOnChartArea:false }, title: { display:true, text: 'â‚¬/Smc' } }
      }
    }
  });
}

/* ================== Forecast defaults (from uploaded bolletta) ================== */
const FORECAST_DEFAULTS = {
  kwh_per_smc: 10.9325,
  oneriHeraPerSmc: 0.62917,
  spesaVenditaPerSmc: 0.481944,
  quotaFissaMensile: 14.20,
  areraStartDate: '2026-01-01',
  oneriAreraPerSmc: 0.18
};

/* ================== Core logic (readings CRUD + forecast + PSV fetch) ================== */
function startEditing(key){
  db.ref('readings/' + key).once('value').then(snap=>{
    const r = snap.val();
    if(!r) return showMessage('Lettura non trovata','error');
    editingKey = key;
    document.getElementById('date').value = r.date || '';
    const dt = r.datetime || '';
    document.getElementById('time').value = dt.slice(11,16) || '';
    document.getElementById('reading').value = r.reading;
    document.getElementById('temp').value = (typeof r.temperature !== 'undefined' && r.temperature !== null) ? r.temperature : '';
    document.getElementById('notes').value = r.notes || '';
    document.getElementById('addBtn').dataset.origTimestamp = r.timestamp || '';
    document.getElementById('addBtn').textContent = 'Aggiorna';
    document.getElementById('cancelEditBtn').style.display = '';
    showMessage('Modifica in corso â€” premi Aggiorna per salvare', 'ok');
  }).catch(e=> showMessage('Errore: '+e,'error'));
}

function cancelEdit(){
  editingKey = null;
  resetInput();
  document.getElementById('addBtn').textContent = 'Aggiungi';
  document.getElementById('cancelEditBtn').style.display = 'none';
  delete document.getElementById('addBtn').dataset.origTimestamp;
  showMessage('Modifica annullata','ok');
}

function resetInput(){
  const today = new Date(); document.getElementById('date').value = today.toISOString().slice(0,10);
  document.getElementById('reading').value = '';
  document.getElementById('time').value = '';
  document.getElementById('temp').value = '';
  document.getElementById('notes').value = '';
}

function addReading(){
  const date = document.getElementById('date').value;
  const readingRaw = document.getElementById('reading').value;
  const time = document.getElementById('time').value;
  const tempRaw = document.getElementById('temp').value;
  const notes = document.getElementById('notes').value || '';

  if(!date || readingRaw === '') { showMessage('Inserisci data e lettura','error'); return; }
  const reading = parseFloat(readingRaw);
  const temperature = tempRaw === '' ? null : parseFloat(tempRaw);
  const datetime = isoWithTime(date, time);

  if(editingKey){
    // update WITHOUT changing original timestamp; record updatedAt
    const updates = {};
    updates['/readings/' + editingKey + '/date'] = date;
    updates['/readings/' + editingKey + '/datetime'] = datetime;
    updates['/readings/' + editingKey + '/reading'] = reading;
    updates['/readings/' + editingKey + '/temperature'] = temperature;
    updates['/readings/' + editingKey + '/notes'] = notes;
    updates['/readings/' + editingKey + '/updatedAt'] = Date.now();
    db.ref().update(updates).then(()=>{
      showMessage('Lettura aggiornata','ok');
      editingKey = null;
      delete document.getElementById('addBtn').dataset.origTimestamp;
      document.getElementById('addBtn').textContent = 'Aggiungi';
      document.getElementById('cancelEditBtn').style.display = 'none';
      resetInput();
      loadAll();
    }).catch(err=> showMessage('Errore: '+err,'error'));
    return;
  }

  // new reading
  const timestamp = Date.now();
  const newKey = db.ref('readings').push().key;
  const updates = {};
  updates['/readings/' + newKey] = { date, datetime, reading, temperature, notes, timestamp };
  // persist settings (price_mp, fixed_charge)
  updates['/settings/price_mp'] = parseFloat(document.getElementById('price_mp').value) || 0;
  updates['/settings/fixed_charge'] = parseFloat(document.getElementById('fixed_charge').value) || 0;

  db.ref().update(updates)
    .then(()=>{ showMessage('Lettura salvata','ok'); resetInput(); loadAll(); })
    .catch(err=> showMessage('Errore: '+err,'error'));
}

function deleteReading(key){
  if(!confirm('Eliminare questa lettura?')) return;
  if(editingKey === key) cancelEdit();
  db.ref('readings/' + key).remove().then(()=>{ showMessage('Lettura eliminata','ok'); loadAll(); }).catch(e=>showMessage('Errore: '+e,'error'));
}

function clearAll(){
  if(!confirm('Cancellare tutte le letture?')) return;
  db.ref('readings').remove().then(()=>{ showMessage('Tutti i dati cancellati','ok'); loadAll(); }).catch(e=>showMessage('Errore: '+e,'error'));
}

/* ========== PSV fetch & parse (client-side attempt) ==========
   NOTE: many GME endpoints block CORS; prefer server-side fetch.
   This client attempt tries to fetch a CSV/JSON URL; replace GME_CSV_URL with your feed.
   If fetch fails, user can input PSV manually in â‚¬/MWh or â‚¬/Smc.
================================================================= */
const GME_CSV_URL_PLACEHOLDER = 'https://www.mercatoelettrico.org/it/dati/mercatogas_esiti'; // <- replace with real CSV/JSON endpoint if available

async function fetchAndStorePSV() {
  // Try common JSON endpoints first (placeholder). If fail, show message.
  try {
    // Example attempt: fetch CSV-like resource (adjust to real URL that returns CSV/JSON)
    const url = GME_CSV_URL_PLACEHOLDER; // replace with real URL if you have it
    showMessage('Tentativo fetch PSV: ' + url, 'ok');
    const resp = await fetch(url, {mode:'cors'});
    if(!resp.ok) throw new Error('Fetch failed: ' + resp.status);
    const text = await resp.text();
    // Try to parse CSV lines with pattern date;price
    const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
    const parsed = [];
    for(const line of lines){
      // naive CSV parse: find two numbers in the line
      const m = line.match(/(\d{4}-\d{2}-\d{2}).*?([0-9]+(?:[.,][0-9]+)?)/);
      if(m){
        const date = m[1];
        const priceMWh = parseFloat(m[2].replace(',', '.'));
        parsed.push({ date, priceMWh });
      }
    }
    if(parsed.length===0) throw new Error('Parsing PSV non riuscito (formato inatteso)');
    // convert â‚¬/MWh -> â‚¬/Smc using kWh_per_smc (from forecast params stored in DB or defaults)
    const forecastParamsSnap = await db.ref('forecastParams').once('value');
    const fp = forecastParamsSnap.val() || {};
    const kwh_per_smc = fp.kwh_per_smc || FORECAST_DEFAULTS.kwh_per_smc;
    const factor = 1000 / kwh_per_smc;
    const store = parsed.map(p => ({ date: p.date, priceMWh: p.priceMWh, priceSmc: (p.priceMWh / factor) }));
    // save to Firebase under /psv/YYYY-MM
    const month = store[0].date.slice(0,7);
    const updates = {};
    updates['/psv/' + month] = store;
    updates['/psv_meta/lastFetched'] = Date.now();
    updates['/psv_meta/lastCount'] = store.length;
    await db.ref().update(updates);
    showMessage('PSV scaricati e salvati: ' + store.length + ' righe', 'ok');
    // update UI
    document.getElementById('psv_last_count').textContent = store.length;
    document.getElementById('psv_last_time').textContent = new Date().toISOString().slice(0,19).replace('T',' ');
    // recompute forecast/chart
    loadAll();
    return store;
  } catch (err) {
    showMessage('Fetch PSV fallito: ' + err.message, 'error');
    return null;
  }
}

/* ========== Helper: compute forecast ========== */
function computeForecastFromInputs(opts){
  // opts: {lettura, dataISO, daysInMonth, psvMwhInput, psvSmcInput}
  const lettura = Number(opts.lettura) || 0;
  const dataISO = opts.dataISO || (new Date().toISOString().slice(0,10));
  const days = Number(opts.daysInMonth) || (new Date(dataISO.slice(0,4), Number(dataISO.slice(5,7)), 0).getDate());
  const giorno = new Date(dataISO).getDate() || 1;
  const consumoPrevisto = (giorno>0) ? (lettura * (days / giorno)) : lettura;

  // obtain forecast params from DB (synchronously we will read cached copy stored at window.__forecastParams)
  const fp = window.__forecastParams || FORECAST_DEFAULTS;
  // price selection: priority: psvSmcInput -> psvMwhInput converted -> if missing, average PSV from DB month -> fallback spesaVenditaPerSmc
  let psmc = null;
  if(opts.psvSmcInput && !isNaN(Number(opts.psvSmcInput))) psmc = Number(opts.psvSmcInput);
  else if(opts.psvMwhInput && !isNaN(Number(opts.psvMwhInput))){
    const factor = 1000 / (fp.kwh_per_smc || FORECAST_DEFAULTS.kwh_per_smc);
    psmc = Number(opts.psvMwhInput) / factor;
  } else {
    // try to read /psv for current month in window.__psvCache (populated by loadAll)
    const month = dataISO.slice(0,7);
    const psvCache = window.__psvCache && window.__psvCache[month];
    if(psvCache && psvCache.length){
      const avg = psvCache.reduce((s,p)=>s + (p.priceSmc||0),0) / psvCache.length;
      psmc = avg;
    } else {
      psmc = fp.spesaVenditaPerSmc || FORECAST_DEFAULTS.spesaVenditaPerSmc;
    }
  }

  // choose oneri depending on date (Hera or ARERA transition)
  const areraStart = new Date(fp.areraStartDate || FORECAST_DEFAULTS.areraStartDate);
  const oneriPerSmc = (new Date(dataISO) >= areraStart) ? (fp.oneriAreraPerSmc || FORECAST_DEFAULTS.oneriAreraPerSmc) : (fp.oneriHeraPerSmc || FORECAST_DEFAULTS.oneriHeraPerSmc);

  const costoMateria = consumoPrevisto * psmc;
  const costoOneri = consumoPrevisto * oneriPerSmc;
  const totale = costoMateria + costoOneri + (fp.quotaFissaMensile || FORECAST_DEFAULTS.quotaFissaMensile);

  return {
    consumoPrevisto, psmc, costoMateria, costoOneri, quota: fp.quotaFissaMensile || FORECAST_DEFAULTS.quotaFissaMensile, totale, oneriPerSmc
  };
}

/* ========== Load & Render (reads settings, psv, readings) ========== */
async function loadAll(){
  try {
    const [snapR, snapS, snapPsv, snapFp] = await Promise.all([
      db.ref('readings').once('value'),
      db.ref('settings').once('value'),
      db.ref('psv').once('value'),
      db.ref('forecastParams').once('value')
    ]);
    const readingsObj = snapR.val() || {};
    const settings = snapS.val() || {};
    const psvObj = snapPsv.val() || {};
    const forecastParams = snapFp.val() || {};

    // merge forecast params into cached object
    window.__forecastParams = Object.assign({}, FORECAST_DEFAULTS, forecastParams);

    // load settings into fields
    if(typeof settings.price_mp !== 'undefined') document.getElementById('price_mp').value = settings.price_mp;
    if(typeof settings.fixed_charge !== 'undefined') document.getElementById('fixed_charge').value = settings.fixed_charge;

    // load psv meta
    const psvMetaSnap = await db.ref('psv_meta').once('value');
    const psvMeta = psvMetaSnap.val() || {};
    document.getElementById('psv_last_count').textContent = psvMeta.lastCount || 0;
    document.getElementById('psv_last_time').textContent = psvMeta.lastFetched ? new Date(psvMeta.lastFetched).toISOString().slice(0,19).replace('T',' ') : '-';

    // cache psv in window for computeForecast
    window.__psvCache = psvObj;

    // render readings and computed stats
    renderAll(readingsObj, settings);
    // update forecast inputs defaults from forecastParams
    // put default kwh etc in UI if you like (we don't expose all fields in UI to avoid clutter)
    window.__forecastParams = Object.assign({}, FORECAST_DEFAULTS, forecastParams);
  } catch (err){
    showMessage('Errore loadAll: '+err,'error');
  }
}

function renderAll(readingsObj, settings){
  const arr = Object.keys(readingsObj).map(k=>({ key: k, ...readingsObj[k] }));
  arr.sort((a,b)=> Number(a.timestamp||0) - Number(b.timestamp||0));

  // render table
  const tbody = document.getElementById('readingsBody'); tbody.innerHTML = '';
  arr.slice().reverse().forEach(r=>{
    const time = (r.datetime||'').slice(11,19) || '-';
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${r.date}</td><td>${time}</td><td>${Number(r.reading).toFixed(3)}</td><td>${r.temperature!==null && typeof r.temperature!=='undefined' ? r.temperature : '-'}</td><td>${(r.notes||'')}</td>
      <td>
        <button class="small-action muted-btn" onclick="startEditing('${r.key}')">Modifica</button>
        <button class="small-action ghost" onclick="deleteReading('${r.key}')">Elimina</button>
      </td>`;
    tbody.appendChild(tr);
  });

  // group by date (asc)
  const byDate = {};
  arr.forEach(r=>{
    if(!r.date) return;
    if(!byDate[r.date]) byDate[r.date] = [];
    byDate[r.date].push(r);
  });
  const dates = Object.keys(byDate).sort();

  // lastPerDay and intra-day totals
  const lastPerDay = [];
  const intraDay = {};
  dates.forEach(d=>{
    const list = byDate[d]; // asc
    if(!list || list.length===0) return;
    const first = list[0], last = list[list.length-1];
    lastPerDay.push({ date:d, reading: Number(last.reading), key: last.key, timestamp: last.timestamp || 0 });
    if(list.length>=2){
      const total = Number(last.reading) - Number(first.reading);
      intraDay[d] = (!isNaN(total) && total>=0) ? total : null;
    }
  });

  // daily consumption: diff between consecutive lastPerDay
  const dailyConsumption = [];
  for(let i=1;i<lastPerDay.length;i++){
    const cur = lastPerDay[i];
    const prev = lastPerDay[i-1];
    const diff = Number(cur.reading) - Number(prev.reading);
    dailyConsumption.push({ date: cur.date, consumption: (!isNaN(diff) && diff >= 0) ? diff : null });
  }

  // average daily
  const validDaily = dailyConsumption.filter(x=>x.consumption!==null).map(x=>x.consumption);
  const avgDaily = validDaily.length ? (validDaily.reduce((a,b)=>a+b,0)/validDaily.length) : null;

  // today's intra-day if present
  const today = new Date().toISOString().slice(0,10);
  const todayIntra = intraDay[today] || null;

  const estDailySmc = (avgDaily !== null) ? avgDaily : (todayIntra !== null ? todayIntra : null);
  const estWeeklySmc = estDailySmc !== null ? estDailySmc * 7 : null;
  const estMonthly = estDailySmc !== null ? estDailySmc * 30 : null;

  const priceMp = (settings && typeof settings.price_mp !== 'undefined') ? settings.price_mp : parseFloat(document.getElementById('price_mp').value) || 0;
  const fixedCharge = (settings && typeof settings.fixed_charge !== 'undefined') ? settings.fixed_charge : parseFloat(document.getElementById('fixed_charge').value) || 0;
  const fixedPerDay = fixedCharge / 30;
  const estDailyCost = estDailySmc !== null ? (estDailySmc * priceMp + fixedPerDay) : null;
  const estWeeklyCost = estWeeklySmc !== null ? (estWeeklySmc * priceMp + fixedPerDay*7) : null;
  const estMonthlyCost = estMonthly !== null ? (estMonthly * priceMp + fixedCharge) : null;

  // update DOM stats
  document.getElementById('total').textContent = dates.length;
  document.getElementById('avgDaily').textContent = avgDaily !== null ? avgDaily.toFixed(3) + ' Smc/g' : '-';
  document.getElementById('estDailySmc').textContent = estDailySmc !== null ? estDailySmc.toFixed(3) + ' Smc' : '-';
  document.getElementById('estWeeklySmc').textContent = estWeeklySmc !== null ? estWeeklySmc.toFixed(3) + ' Smc' : '-';
  document.getElementById('estMonthlySmc').textContent = estMonthly !== null ? estMonthly.toFixed(1) + ' Smc' : '-';
  document.getElementById('estMonthlyCost').textContent = estMonthlyCost !== null ? estMonthlyCost.toFixed(2) + ' â‚¬' : '-';
  document.getElementById('estDailyCost').textContent = estDailyCost !== null ? estDailyCost.toFixed(2) + ' â‚¬' : '-';
  document.getElementById('estWeeklyCost').textContent = estWeeklyCost !== null ? estWeeklyCost.toFixed(2) + ' â‚¬' : '-';
  document.getElementById('todayConsumption').textContent = todayIntra !== null ? (todayIntra.toFixed(3) + ' Smc') : '-';

  // update chart (labels: lastPerDay.dates ; data: lastPerDay.reading) and overlay PSV if available
  const labels = lastPerDay.map(x=>x.date);
  const data = lastPerDay.map(x=>x.reading);

  // get PSV series for months present in lastPerDay (take most recent month)
  const months = Object.keys(window.__psvCache || {});
  let psvSeries = [];
  let psvLabels = [];
  if(months.length){
    // choose current month if present, otherwise most recent
    const currentMonth = (new Date()).toISOString().slice(0,7);
    const chosen = window.__psvCache[currentMonth] ? currentMonth : months[months.length-1];
    const arr = window.__psvCache[chosen] || [];
    psvLabels = arr.map(p=>p.date);
    psvSeries = arr.map(p=>p.priceSmc);
    document.getElementById('psv_last_count').textContent = arr.length;
  } else {
    document.getElementById('psv_last_count').textContent = 0;
  }

  // combine labels for chart (unique union)
  const unionLabels = Array.from(new Set([...labels, ...psvLabels])).sort();

  // map data to union labels
  const dataForChart = unionLabels.map(lbl=>{
    const idx = labels.indexOf(lbl);
    return idx>=0 ? data[idx] : null;
  });
  const psvForChart = unionLabels.map(lbl=>{
    const idx = psvLabels.indexOf(lbl);
    return idx>=0 ? psvSeries[idx] : null;
  });

  updateChart(unionLabels, dataForChart, psvForChart);

  // monthly aggregation (min/max approach)
  const byMonth = {};
  arr.forEach(r=>{
    if(!r.date) return;
    const ym = r.date.slice(0,7);
    const val = Number(r.reading);
    if(isNaN(val)) return;
    if(!byMonth[ym]) byMonth[ym] = { min: val, max: val, dates: new Set() };
    byMonth[ym].dates.add(r.date);
    if(val < byMonth[ym].min) byMonth[ym].min = val;
    if(val > byMonth[ym].max) byMonth[ym].max = val;
  });

  // render monthly table
  const monthsKeys = Object.keys(byMonth).sort().reverse();
  const monthlyBody = document.getElementById('monthlyBody'); monthlyBody.innerHTML = '';
  monthsKeys.forEach(m=>{
    const obj = byMonth[m];
    let consumption = null;
    if(typeof obj.min !== 'undefined' && typeof obj.max !== 'undefined' && obj.max >= obj.min) consumption = obj.max - obj.min;
    const [y, mm] = m.split('-').map(Number);
    const daysInMonth = new Date(y, mm, 0).getDate();
    const avgPerCalendarDay = consumption !== null ? (consumption / daysInMonth) : null;
    const cost = consumption !== null ? (consumption * priceMp + fixedCharge) : null;
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${m}</td><td>${consumption!==null?consumption.toFixed(3)+' Smc':'-'}</td><td>${avgPerCalendarDay!==null?avgPerCalendarDay.toFixed(3)+' Smc/g':'-'}</td><td>${cost!==null?cost.toFixed(2)+' â‚¬':'-'}</td>`;
    monthlyBody.appendChild(tr);
  });

  window.__computed = { lastPerDay, intraDay, dailyConsumption, byMonth, priceMp, fixedCharge };
}

/* ========== Chart update ========== */
function updateChart(labels, smcData, psvData){
  if(!chart) return;
  chart.data.labels = labels;
  chart.data.datasets[0].data = smcData.map(v => v===null ? null : Number(v));
  chart.data.datasets[1].data = psvData.map(v => v===null ? null : Number(v));
  chart.update();
}

/* ========== Export / Import ========== */
function exportCsv(){
  db.ref('readings').once('value').then(snap=>{
    const obj = snap.val() || {};
    const rows = [['key','date','datetime','reading','temperature','notes','timestamp']];
    Object.keys(obj).forEach(k=>{
      const r = obj[k];
      rows.push([k, r.date||'', r.datetime||'', r.reading||'', r.temperature||'', (r.notes||'').replace(/"/g,'""'), r.timestamp||'']);
    });
    const csv = rows.map(r=>r.map(c=>`"${String(c).replace(/"/g,'""')}"`).join(',')).join('\n');
    const blob = new Blob([csv], { type:'text/csv' }); const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'gas_readings.csv'; a.click(); URL.revokeObjectURL(url);
  });
}

function importCsvHandler(file){
  if(!file) return;
  const reader = new FileReader();
  reader.onload = e=>{
    const text = e.target.result;
    const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
    if(lines.length<=1){ showMessage('CSV vuoto o non valido','error'); return; }
    const dataLines = lines.slice(1);
    const updates = {};
    dataLines.forEach(line=>{
      const cols = splitCsvLine(line);
      if(cols.length < 6) return;
      const key = cols[0] || db.ref('readings').push().key;
      updates['/readings/' + key] = {
        date: cols[1],
        datetime: cols[2],
        reading: parseFloat(cols[3])||0,
        temperature: cols[4] === '' ? null : parseFloat(cols[4]),
        notes: cols[5] || '',
        timestamp: cols[6] ? Number(cols[6]) : Date.now()
      };
    });
    if(Object.keys(updates).length===0){ showMessage('Nessuna riga valida nel CSV','error'); return; }
    db.ref().update(updates).then(()=>{ showMessage('Import completato','ok'); loadAll(); }).catch(e=>showMessage('Errore import: '+e,'error'));
  };
  reader.readAsText(file);
}
function splitCsvLine(line){
  const res=[]; let cur=''; let inQ=false;
  for(let i=0;i<line.length;i++){
    const c=line[i];
    if(c==='\"'){ if(inQ && line[i+1]==='\"'){ cur+='"'; i++; continue;} inQ=!inQ; continue;}
    if(c===',' && !inQ){ res.push(cur); cur=''; continue;}
    cur += c;
  }
  res.push(cur);
  return res.map(s=>s.replace(/^"|"$/g,'').trim());
}

/* ========== Overlay history ========== */
// ... (same overlay functions as before) ...
function openOverlay(defaultTab='daily'){
  const overlay = document.getElementById('overlay');
  overlay.classList.add('active');
  overlay.setAttribute('aria-hidden','false');
  selectHistoryTab(defaultTab);
  renderHistory(defaultTab);
}
function closeOverlay(){ const overlay = document.getElementById('overlay'); overlay.classList.remove('active'); overlay.setAttribute('aria-hidden','true'); }
function selectHistoryTab(tab){
  document.querySelectorAll('#historyTabs button').forEach(b=>b.classList.toggle('active', b.dataset.tab===tab));
  renderHistory(tab);
}

function renderHistory(tab){
  // reuse previous implementation (omitted here for brevity but present above)
  const content = document.getElementById('historyContent');
  content.innerHTML = '';
  const computed = window.__computed || {};
  const lastPerDay = computed.lastPerDay || [];
  const dailyConsumption = computed.dailyConsumption || [];
  const byMonth = computed.byMonth || {};
  if(tab==='daily'){
    const fragment = document.createDocumentFragment();
    const header = document.createElement('div'); header.className='small'; header.textContent = 'Consumo giornaliero (ultima_lettura_giorno - ultima_lettura_giorno_precedente)';
    fragment.appendChild(header);
    const grouped = {};
    dailyConsumption.slice().reverse().forEach(d=>{
      const ym = d.date.slice(0,7);
      if(!grouped[ym]) grouped[ym]=[];
      grouped[ym].push(d);
    });
    Object.keys(grouped).sort().reverse().forEach(ym=>{
      const g = document.createElement('div'); g.className='group';
      g.innerHTML = `<h5>${ym} â€” ${grouped[ym].length} giorni</h5>`;
      const ul = document.createElement('div');
      grouped[ym].forEach(item=>{
        const v = item.consumption !== null ? item.consumption.toFixed(3) + ' Smc' : '-';
        const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='space-between'; row.style.padding='6px 0';
        row.innerHTML = `<div>${item.date}</div><div style="color:var(--muted)">${v}</div>`;
        ul.appendChild(row);
      });
      g.appendChild(ul); fragment.appendChild(g);
    });
    content.appendChild(fragment);
  } else if(tab==='monthly'){
    const frag = document.createDocumentFragment();
    const header = document.createElement('div'); header.className='small'; header.textContent='Aggregato mensile (min/max reading del mese)';
    frag.appendChild(header);
    const months = Object.keys(byMonth).sort().reverse();
    months.forEach(m=>{
      const obj = byMonth[m];
      const consumption = (typeof obj.min!=='undefined' && typeof obj.max!=='undefined' && obj.max>=obj.min) ? (obj.max - obj.min) : null;
      const recDays = obj.dates ? obj.dates.size : 0;
      const div = document.createElement('div'); div.className='group';
      div.innerHTML = `<h5>${m}</h5><div>Consumo: ${consumption!==null?consumption.toFixed(3)+' Smc':'-'}</div><div>Giorni registrati: ${recDays}</div>`;
      frag.appendChild(div);
    });
    content.appendChild(frag);
  } else if(tab==='yearly'){
    const years = {};
    Object.keys(byMonth).forEach(m=>{
      const y = m.slice(0,4);
      const obj = byMonth[m];
      const consumption = (typeof obj.min!=='undefined' && typeof obj.max!=='undefined' && obj.max>=obj.min) ? (obj.max - obj.min) : null;
      if(!years[y]) years[y] = { months: [], total:0, valid:false };
      years[y].months.push({month:m, consumption});
      if(consumption!==null){ years[y].total += consumption; years[y].valid = true; }
    });
    const frag = document.createDocumentFragment();
    Object.keys(years).sort().reverse().forEach(y=>{
      const info = years[y];
      const div = document.createElement('div'); div.className='group';
      div.innerHTML = `<h5>${y}</h5><div>Consumo totale anno: ${info.valid?info.total.toFixed(3)+' Smc':'-'}</div><div>Numero mesi registrati: ${info.months.length}</div>`;
      frag.appendChild(div);
    });
    content.appendChild(frag);
  }
}

function exportHistoryView(){
  const active = document.querySelector('#historyTabs button.active').dataset.tab;
  const computed = window.__computed || {};
  let rows = [];
  if(active==='daily'){
    rows.push(['date','consumption_smc']);
    (computed.dailyConsumption||[]).forEach(d=> rows.push([d.date, d.consumption!==null?d.consumption:'']));
  } else if(active==='monthly'){
    rows.push(['month','min','max','consumption','recorded_days']);
    const byMonth = computed.byMonth || {};
    Object.keys(byMonth).sort().forEach(m=>{
      const b = byMonth[m];
      const min = b.min; const max = b.max;
      const consumption = (typeof min!=='undefined' && typeof max!=='undefined' && max>=min) ? (max-min): '';
      rows.push([m, min||'', max||'', consumption||'', b.dates?b.dates.size:'']);
    });
  } else if(active==='yearly'){
    rows.push(['year','total_consumption','months_recorded']);
    const byMonth = computed.byMonth || {};
    const years = {};
    Object.keys(byMonth).forEach(m=>{
      const y = m.slice(0,4);
      if(!years[y]) years[y] = { total:0, count:0, valid:false };
      const min = byMonth[m].min; const max = byMonth[m].max;
      const consumption = (typeof min!=='undefined' && typeof max!=='undefined' && max>=min) ? (max-min): 0;
      if(consumption) { years[y].total += consumption; years[y].valid = true; }
      years[y].count++;
    });
    Object.keys(years).sort().forEach(y=>{
      rows.push([y, years[y].valid?years[y].total:'', years[y].count]);
    });
  }
  const csv = rows.map(r => r.map(c => `"${String(c).replace(/"/g,'""')}"`).join(',')).join('\n');
  const blob = new Blob([csv], { type:'text/csv' }); const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'history.csv'; a.click(); URL.revokeObjectURL(url);
}

/* ========== Events & init ========== */
document.addEventListener('DOMContentLoaded', ()=>{
  initChart();
  document.getElementById('date').value = new Date().toISOString().slice(0,10);

  // stat clicks -> open overlay with tab
  document.getElementById('statAvgDaily').addEventListener('click', ()=>openOverlay('daily'));
  document.getElementById('statEstDaily').addEventListener('click', ()=>openOverlay('daily'));
  document.getElementById('statEstMonthly').addEventListener('click', ()=>openOverlay('monthly'));
  document.getElementById('statEstMonthlyCost').addEventListener('click', ()=>openOverlay('monthly'));
  document.getElementById('statTotal').addEventListener('click', ()=>openOverlay('daily'));

  // buttons
  const addBtn = document.getElementById('addBtn');
  addBtn.addEventListener('click', addReading);
  addBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); addReading(); });

  document.getElementById('cancelEditBtn').addEventListener('click', cancelEdit);
  document.getElementById('clearBtn').addEventListener('click', clearAll);
  document.getElementById('exportBtn').addEventListener('click', exportCsv);

  const importBtn = document.getElementById('importBtn');
  const fileInput = document.getElementById('fileImport');
  importBtn.addEventListener('click', ()=> fileInput.click());
  fileInput.addEventListener('change', ev=>{ const f = ev.target.files && ev.target.files[0]; if(f) importCsvHandler(f); fileInput.value = ''; });

  // overlay controls
  document.getElementById('closeOverlay').addEventListener('click', closeOverlay);
  document.querySelectorAll('#historyTabs button').forEach(b=>{ b.addEventListener('click', ()=> selectHistoryTab(b.dataset.tab)); });
  document.getElementById('exportHistoryBtn').addEventListener('click', exportHistoryView);

  // logo fallback
  const logo = document.getElementById('logoImg');
  logo.addEventListener('error', ()=>{
    if(logo.src && logo.src.endsWith('.svg')) logo.src = 'icon-180.png';
    else { const p = logo.parentElement; p.removeChild(logo); const txt = document.createElement('div'); txt.style.fontWeight='800'; txt.textContent='GAS T.'; p.insertBefore(txt,p.firstChild); }
  });

  // forecast UI events
  document.getElementById('btnFetchPsv').addEventListener('click', async ()=> {
    document.getElementById('btnFetchPsv').textContent = 'Fetching...';
    await fetchAndStorePSV();
    document.getElementById('btnFetchPsv').textContent = 'Fetch PSV';
  });

  document.getElementById('btnCalcForecast').addEventListener('click', ()=>{
    const lett = document.getElementById('forecast_lettura_input').value.trim();
    const data = document.getElementById('forecast_date_input').value || new Date().toISOString().slice(0,10);
    const days = new Date(data.slice(0,4), Number(data.slice(5,7)), 0).getDate();
    const psvMwh = document.getElementById('forecast_psv_mwh').value.trim();
    const psvSmc = document.getElementById('forecast_psv_smc').value.trim();
    const res = computeForecastFromInputs({ lettura: lett, dataISO: data, daysInMonth: days, psvMwhInput: psvMwh, psvSmcInput: psvSmc});
    const out = document.getElementById('forecast_output');
    out.style.display = 'block';
    out.innerHTML = `<div><strong>Consumo previsto:</strong> ${res.consumoPrevisto.toFixed(3)} Smc</div>
                     <div><strong>Prezzo materia usato:</strong> ${res.psmc.toFixed(5)} â‚¬/Smc</div>
                     <div><strong>Spesa materia:</strong> â‚¬ ${res.costoMateria.toFixed(2)}</div>
                     <div><strong>Spesa oneri:</strong> â‚¬ ${res.costoOneri.toFixed(2)} (â‚¬/Smc = ${res.oneriPerSmc.toFixed(4)})</div>
                     <div><strong>Quota fissa:</strong> â‚¬ ${res.quota.toFixed(2)}</div>
                     <hr><h3>Totale stimato: â‚¬ ${res.totale.toFixed(2)}</h3>`;
  });

  document.getElementById('btnResetForecast').addEventListener('click', ()=> {
    document.getElementById('forecast_psv_mwh').value='';
    document.getElementById('forecast_psv_smc').value='';
    document.getElementById('forecast_lettura_input').value='';
    document.getElementById('forecast_date_input').value = new Date().toISOString().slice(0,10);
    document.getElementById('forecast_output').style.display='none';
  });

  document.getElementById('btnSaveForecastParams').addEventListener('click', async ()=>{
    // save current forecast defaults into /forecastParams in Firebase
    const fp = {
      kwh_per_smc: FORECAST_DEFAULTS.kwh_per_smc,
      oneriHeraPerSmc: FORECAST_DEFAULTS.oneriHeraPerSmc,
      spesaVenditaPerSmc: FORECAST_DEFAULTS.spesaVenditaPerSmc,
      quotaFissaMensile: FORECAST_DEFAULTS.quotaFissaMensile,
      areraStartDate: FORECAST_DEFAULTS.areraStartDate,
      oneriAreraPerSmc: FORECAST_DEFAULTS.oneriAreraPerSmc
    };
    // you can expand UI to let user edit these before saving; for now we save defaults
    await db.ref('forecastParams').set(fp);
    showMessage('Parametri previsione salvati in Firebase', 'ok');
  });

  // export/import buttons
  document.getElementById('exportBtn').addEventListener('click', exportCsv);
  document.getElementById('importBtn').addEventListener('click', ()=> document.getElementById('fileImport').click());
  document.getElementById('fileImport').addEventListener('change', ev=> { const f = ev.target.files && ev.target.files[0]; if(f) importCsvHandler(f); ev.target.value=''; });

  // load initial data
  loadAll();
});
</script>
</body>
</html>